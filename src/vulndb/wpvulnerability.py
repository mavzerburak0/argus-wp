"""
WPVulnerability.com API integration for WordPress vulnerability lookups.
Free API with comprehensive WordPress core, plugin, and theme vulnerability data.
"""
import json
import re
from typing import List, Dict, Optional
from src.core.http_client import HTTPClient
from src.utils.logger import Output


class WPVulnerabilityDatabase:
    """
    Interface to WPVulnerability.com's free vulnerability database.
    No API key required!
    """

    BASE_URL = "https://www.wpvulnerability.net"

    def __init__(self, http_client: HTTPClient, output: Output):
        """
        Initialize WPVulnerability database client.

        Args:
            http_client: HTTP client instance
            output: Output handler
        """
        self.http_client = http_client
        self.output = output

    def search_wordpress_vulnerabilities(self, version: str) -> List[Dict]:
        """
        Search for WordPress core vulnerabilities for a specific version.

        Args:
            version: WordPress version (e.g., "6.4.2")

        Returns:
            List of vulnerability dictionaries
        """
        self.output.debug(f"Searching WPVulnerability database for WordPress {version}...")

        # API endpoint: https://www.wpvulnerability.net/core/VERSION
        url = f"{self.BASE_URL}/core/{version}"

        response = self.http_client.get(url, use_cache=True)

        if not response or response.status_code != 200:
            self.output.debug(f"Failed to fetch vulnerabilities from WPVulnerability (HTTP {response.status_code if response else 'N/A'})")
            return []

        try:
            data = json.loads(response.text)

            # Check for error
            if data.get("error", 0) != 0:
                self.output.debug(f"API returned error: {data.get('message', 'Unknown error')}")
                return []

            # Extract vulnerability data
            vulnerabilities = []
            core_data = data.get("data", {})
            vuln_list = core_data.get("vulnerability") or []

            for vuln_entry in vuln_list:
                # Check if this vulnerability actually affects our version
                if self._version_affected(version, vuln_entry.get("operator", {})):
                    vuln = self._parse_vulnerability(vuln_entry, "core")
                    if vuln:
                        vulnerabilities.append(vuln)

            return vulnerabilities

        except (json.JSONDecodeError, KeyError, ValueError) as e:
            self.output.debug(f"Error parsing WPVulnerability response: {str(e)}")
            return []

    def search_plugin_vulnerabilities(self, plugin_slug: str, version: Optional[str] = None) -> List[Dict]:
        """
        Search for plugin vulnerabilities.

        Args:
            plugin_slug: Plugin slug name
            version: Optional plugin version

        Returns:
            List of vulnerability dictionaries
        """
        self.output.debug(f"Searching WPVulnerability database for plugin '{plugin_slug}'...")

        # API endpoint: https://www.wpvulnerability.net/plugin/SLUG
        # Note: .net for plugins, not .com
        url = f"https://www.wpvulnerability.net/plugin/{plugin_slug}"

        response = self.http_client.get(url, use_cache=True)

        if not response or response.status_code != 200:
            self.output.debug(f"Failed to fetch plugin vulnerabilities (HTTP {response.status_code if response else 'N/A'})")
            return []

        try:
            data = json.loads(response.text)

            # Check for error
            if data.get("error", 0) != 0:
                self.output.debug(f"API returned error: {data.get('message', 'Unknown error')}")
                return []

            # Extract vulnerability data
            vulnerabilities = []
            plugin_data = data.get("data", {})
            vuln_list = plugin_data.get("vulnerability") or []

            for vuln_entry in vuln_list:
                # If version is specified, check if it's affected
                if version:
                    if not self._version_affected(version, vuln_entry.get("operator", {})):
                        continue

                vuln = self._parse_vulnerability(vuln_entry, "plugin")
                if vuln:
                    vulnerabilities.append(vuln)

            return vulnerabilities

        except (json.JSONDecodeError, KeyError, ValueError) as e:
            self.output.debug(f"Error parsing plugin vulnerabilities: {str(e)}")
            return []

    def search_theme_vulnerabilities(self, theme_slug: str, version: Optional[str] = None) -> List[Dict]:
        """
        Search for theme vulnerabilities.

        Args:
            theme_slug: Theme slug name
            version: Optional theme version

        Returns:
            List of vulnerability dictionaries
        """
        self.output.debug(f"Searching WPVulnerability database for theme '{theme_slug}'...")

        # API endpoint: https://www.wpvulnerability.net/theme/SLUG
        url = f"https://www.wpvulnerability.net/theme/{theme_slug}"

        response = self.http_client.get(url, use_cache=True)

        if not response or response.status_code != 200:
            self.output.debug(f"Failed to fetch theme vulnerabilities (HTTP {response.status_code if response else 'N/A'})")
            return []

        try:
            data = json.loads(response.text)

            # Check for error
            if data.get("error", 0) != 0:
                self.output.debug(f"API returned error: {data.get('message', 'Unknown error')}")
                return []

            # Extract vulnerability data
            vulnerabilities = []
            theme_data = data.get("data", {})
            vuln_list = theme_data.get("vulnerability") or []

            for vuln_entry in vuln_list:
                # If version is specified, check if it's affected
                if version:
                    if not self._version_affected(version, vuln_entry.get("operator", {})):
                        continue

                vuln = self._parse_vulnerability(vuln_entry, "theme")
                if vuln:
                    vulnerabilities.append(vuln)

            return vulnerabilities

        except (json.JSONDecodeError, KeyError, ValueError) as e:
            self.output.debug(f"Error parsing theme vulnerabilities: {str(e)}")
            return []

    def _version_affected(self, version: str, operator: Dict) -> bool:
        """
        Check if a version is affected based on operator constraints.

        Args:
            version: Version to check
            operator: Operator dictionary with min/max versions and operators

        Returns:
            True if version is affected
        """
        try:
            # Parse version parts (handle pre-release versions like "3.22.0-beta2")
            version_parts = self._parse_version(version)

            # Check minimum version constraint
            min_version = operator.get("min_version")
            min_operator = operator.get("min_operator")

            if min_version and min_operator:
                min_parts = self._parse_version(min_version)

                if min_operator == "ge":  # >=
                    if not self._version_compare(version_parts, min_parts) >= 0:
                        return False
                elif min_operator == "gt":  # >
                    if not self._version_compare(version_parts, min_parts) > 0:
                        return False

            # Check maximum version constraint
            max_version = operator.get("max_version")
            max_operator = operator.get("max_operator")

            if max_version and max_operator:
                max_parts = self._parse_version(max_version)

                if max_operator == "le":  # <=
                    if not self._version_compare(version_parts, max_parts) <= 0:
                        return False
                elif max_operator == "lt":  # <
                    if not self._version_compare(version_parts, max_parts) < 0:
                        return False

            # Check if marked as unfixed
            if operator.get("unfixed", "0") == "1":
                # If unfixed, all versions are potentially affected
                # But we should still respect min/max constraints
                pass

            return True

        except (ValueError, AttributeError) as e:
            # If we can't parse versions, log and skip this vulnerability
            self.output.debug(f"Error parsing version: {str(e)}")
            return False

    def _parse_version(self, version: str) -> List[int]:
        """
        Parse a version string into comparable integer parts.
        Handles pre-release versions like "3.22.0-beta2" by stripping suffixes.

        Args:
            version: Version string (e.g., "3.22.0" or "3.22.0-beta2")

        Returns:
            List of integers representing version parts
        """
        # Remove pre-release suffixes (alpha, beta, rc, dev, etc.)
        # Examples: "3.22.0-beta2" -> "3.22.0", "1.2.3-rc1" -> "1.2.3"
        import re
        clean_version = re.split(r'[-_]', version)[0]

        # Split by dots and convert to integers
        parts = []
        for part in clean_version.split('.'):
            # Handle cases like "1.2.3a" by extracting only the numeric part
            numeric_part = re.match(r'(\d+)', part)
            if numeric_part:
                parts.append(int(numeric_part.group(1)))

        return parts

    def _version_compare(self, v1: List[int], v2: List[int]) -> int:
        """
        Compare two version number arrays.

        Args:
            v1: First version as list of integers
            v2: Second version as list of integers

        Returns:
            -1 if v1 < v2, 0 if v1 == v2, 1 if v1 > v2
        """
        # Pad shorter version with zeros
        max_len = max(len(v1), len(v2))
        v1_padded = v1 + [0] * (max_len - len(v1))
        v2_padded = v2 + [0] * (max_len - len(v2))

        for i in range(max_len):
            if v1_padded[i] < v2_padded[i]:
                return -1
            elif v1_padded[i] > v2_padded[i]:
                return 1

        return 0

    def _parse_vulnerability(self, vuln_data: Dict, component_type: str) -> Optional[Dict]:
        """
        Parse a vulnerability entry from WPVulnerability API.

        Args:
            vuln_data: Raw vulnerability data
            component_type: Type of component (core, plugin, theme)

        Returns:
            Parsed vulnerability dictionary
        """
        try:
            # Get basic info
            name = vuln_data.get("name", "Unknown")
            description = vuln_data.get("description")

            # Get sources (CVE, Patchstack, Wordfence, etc.)
            sources = vuln_data.get("source", [])

            # Extract CVE IDs and primary description
            cve_ids = []
            primary_description = description if description else ""
            references = []

            for source in sources:
                source_id = source.get("id", "")
                source_link = source.get("link", "")
                source_desc = source.get("description", "")

                # Collect CVE IDs
                if source_id.startswith("CVE-"):
                    cve_ids.append(source_id)

                # Use first detailed description
                if not primary_description and source_desc:
                    primary_description = source_desc

                # Collect reference links
                if source_link:
                    references.append(source_link)

            # Get impact data (CVSS, CWE)
            impact = vuln_data.get("impact", {})
            cvss_data = impact.get("cvss", {}) if isinstance(impact, dict) else {}
            cwe_data = impact.get("cwe", []) if isinstance(impact, dict) else []

            # Extract CVSS score and severity
            cvss_score = cvss_data.get("score", 0.0) if isinstance(cvss_data, dict) else 0.0
            cvss_severity = cvss_data.get("severity", "") if isinstance(cvss_data, dict) else ""

            # Determine severity
            severity = self._determine_severity(cvss_score, cvss_severity)

            # Extract CWE information
            cwe_list = []
            if isinstance(cwe_data, list):
                for cwe in cwe_data:
                    cwe_id = cwe.get("cwe", "")
                    cwe_name = cwe.get("name", "")
                    if cwe_id:
                        cwe_list.append(f"{cwe_id}: {cwe_name}" if cwe_name else cwe_id)

            # Get version range
            operator = vuln_data.get("operator", {})
            version_range = self._format_version_range(operator)

            # Build vulnerability object
            vuln = {
                "cve_id": cve_ids[0] if cve_ids else name,
                "all_cve_ids": cve_ids,
                "summary": primary_description[:500] if primary_description else f"Vulnerability in {name}",
                "severity": severity,
                "cvss_score": cvss_score,
                "cvss_severity": cvss_severity,
                "version_range": version_range,
                "references": references[:5],  # Limit to 5 references
                "cwe": cwe_list,
                "component_type": component_type,
                "unfixed": operator.get("unfixed", "0") == "1",
            }

            return vuln

        except (KeyError, TypeError) as e:
            self.output.debug(f"Error parsing vulnerability entry: {str(e)}")
            return None

    def _determine_severity(self, cvss_score: float, cvss_severity: str) -> str:
        """
        Determine severity level from CVSS data.

        Args:
            cvss_score: CVSS score (0.0-10.0)
            cvss_severity: CVSS severity string

        Returns:
            Severity level: critical, high, medium, low
        """
        # Prefer CVSS severity string if available
        if cvss_severity:
            severity_map = {
                "c": "critical",
                "h": "high",
                "m": "medium",
                "l": "low",
            }
            return severity_map.get(cvss_severity.lower(), cvss_severity.lower())

        # Fall back to score-based severity
        try:
            score = float(cvss_score)
            if score >= 9.0:
                return "critical"
            elif score >= 7.0:
                return "high"
            elif score >= 4.0:
                return "medium"
            else:
                return "low"
        except (ValueError, TypeError):
            return "medium"

    def _format_version_range(self, operator: Dict) -> str:
        """
        Format version range for display.

        Args:
            operator: Operator dictionary

        Returns:
            Formatted version range string
        """
        parts = []

        min_version = operator.get("min_version")
        min_operator = operator.get("min_operator")
        max_version = operator.get("max_version")
        max_operator = operator.get("max_operator")

        if min_version and min_operator:
            symbol = ">=" if min_operator == "ge" else ">"
            parts.append(f"{symbol} {min_version}")

        if max_version and max_operator:
            symbol = "<=" if max_operator == "le" else "<"
            parts.append(f"{symbol} {max_version}")

        if operator.get("unfixed", "0") == "1":
            parts.append("(unfixed)")

        return " and ".join(parts) if parts else "All versions"
